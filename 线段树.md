1. 什么是线段树？

   本质上是一种二叉搜索树，满足二叉树，每个结点最多有两棵子树，并且每个结点上都存储了一个“区间”，这个“区间”可以理解为“线段”。

2. 线段树的应用

   在线、基于区间的修改和查询等操作

   可以处理很多符合“结合律”的操作如加法满足$$$$

3. 线段树 vs 树状数组

   树状数组可以解决的问题都可以用线段树来解决。

   线段树可以用于解决区间问题，但不是仅能区间问题

4. 基本概念

   基本抽象：将线段树看成一棵完全二叉树，左子树的下标是偶数，右子树的下标是奇数。

   ![img](https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017013332469-105750075.png)

5. 基本原理

   实质上是一种分块思想，**理解了结点与结点的关系即可理解线段树**。

   - 建树

     每个叶结点上的值就是数组上的值，每个非叶结点均有两棵子树，且左右孩子分别存储父节点的一半区间。

     **每个父节点的值可以有左右孩子节点的值推导出来**。

     问题一：如何快速找到非叶节点的孩子以及非根节点的父亲？

     首先明确一个点，要将线段树理解成一棵完全二叉树，有些节点可能并未使用，但是仍旧占据了位置！

     根据上面的“明确”：左子树的下标是偶数，右子树的下标是奇数。

     

     ```c++
     // 这里基于区间最大值来建立线段树。
     const int maxn = 100005;
     int a[maxn],t[maxn<<2]; // 使用maxn<<2的原因是需要足够的空间
     void PushUp(int k){
       t[k]=max(t[k<<1],t[k<<1|1]);
     }
     // 递归
     void build(int k,int l,int r){
       // 叶子节点直接赋值
       if (l == r){
         t[k]=a[l];
       }else{
         int m = l+((r-l)>>1);
         build(k<<1,l,m); // 递归构造左孩子
         build(k<<1|1,m+1,r); // 递归构造右孩子
         PushUp(k); // 更新当前节点
       }
     }
     ```

   - 点更新

     单点更新后，所有与之相关的区间都要更新

     ```c++
     void update(int p,int v,int l,int r,int k){
       // p为下标，v为更新的差值，l,r表示节点表示区间，k为节点的下标
       // 叶子节点，直接更新原始数组和线段树数组
       if ( l ==r ) {
         a[k]+=v;
         t[k]+=v;
       }else{
         int m = l + ((r-l)>>1);
         if (p<=m) {
           // 待更新节点在左子树表示的区间内
           update(p,v,l,m,k<<1);
         }else{
           // 待更新节点在右子树表示的区间内
           update(p,v,m+1,r,k<<1|1);
         }
         // 更新当前节点
         PushUp(k)
       }
     }
     ```

   - 区间查询

     从根节点往下递归，如果当前节点表示的区间是查询区间的真子集，则返回当前节点信息且结束递归。

     ```c++
     int query(int L,int R,int l,int r,int k){
       // 当前节点表示的区间是查询区间的真子集
       if (L<=l && r<=R) {
         return t[k];
       }else{
         PushDown(k); // 查询每次都要更新子树的lazy标记
         int res = -INF;
         int m = l + ((r-l)>>1);
         // 如果左孩子节点表示的区间与查询区间有交集
         if (L<=m) {
           res = max(res,query(L,R,l,m,k<<1));
         }
         if (m<R) {
           res = max(res,query(L,R,m+1,r,k<<1|1));
         }
         return res;
       }
     }
     ```

   - 区间更新

     引入Lazy_tag，并非对于每次区间更新都更新区间中的每个值，而是每次更新只更新到更新区间完全覆盖线段树节点区间为止，而其子孙节点的区间得不到需要更新的信息，等到下次访问到这个节点的子节点时将标记传递给子节点。

     递归更新过程中，更新到结点区间为需要更新的区间的真子集就不再往下更新，下次若遇到需要其子孙节点的信息，再将之前的更新传递下去。

     ```c++
     void PushDown(int k){
       if (lazy[k]) {
         // 向下传递标记
         lazy[k<<1] +=lazy[k];
         lazy[k<<1|1] +=lazy[k];
         // 并更新孩子节点的值
         t[k<<1]+=lazy[k];
         t[k<<1|1]+=lazy[k];
         // 清除标记
         lazy[k]=0;
     }
     void rangeUpdate(int L,int R,int v,int l,int r,int k){
       if (L<=l && r<=R){
         lazy[k]+=v;
         t[k]+=v;
       }else{
         // 要先查询更新子树之后再处理
         PushDown(k);
         int m = l+((r-l)>>1);
         // 如果
         if (L<=m) {
           update(L,R,v,l,m,k<<1);
         }
         if (m<R){
           update(L,R,v,m+1,r,k<<1|1);
         }
         // 更新当前节点
         PushUp(k);
       }
     }
     ```

   - TODO：非递归形式

6. 一些技巧

   1. 离散化

      ```C++
      int Rank[maxn],Rn;
      void SetRank(){
      	int I=1;
        sort(Rank+1,Rank+1+Rn);
        // 去重
        for (int i=2;i<=Rn;i++) if (Rank[i]!=Rank[i-1]) Rank[++I]=Rank[i];
        Rn=I;
      }
      int GetRank(int x){
        // 二分法
        int L=1,R=Rn,M;
        while(L!=R){
          M=(L+R)>>1;
          if (Rank[M]<x) L=M+1;
          else R=M;
        }
        return L;
      }
      ```

   2. 可持久化（主席树）

      保留整个操作历史即对一个线段树操作后，保留访问操作前的线段树的能力

      最简单的方法是每次操作建立一棵新树

      优化方向：

      - 对于点修改，每次最多影响log(n-1)+2个节点，本质上线段树结构没有改变，只有log(n-1)+2个节点不同，其余节点都一样，所以每次操作增加log(n-1)+2个节点

   3. 懒惰更新

      区间更新时使用懒惰标记，而不是每次都更新整棵线段树

   4. 空间优化

      考虑使用离散化，压缩空间

      并非所有叶子节点都占用到2n+1 -- 4n，造成了大量的空间浪费

      - 2*n空间表示法

        要求：保证仅有节点的下标和所表示区间的左右端点就能得出其子节点的下标 -- 使用DFS序表示节点下标

        ![img](http://www.cppblog.com/images/cppblog_com/matono1/%E6%8F%8F%E8%BF%B0%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E6%96%B0%E5%BC%8F%E7%BA%BF%E6%AE%B5%E6%A0%91.jpg)

        根节点的下标为1，下标为A的节点的左孩子节点的下标为A+1，右孩子节点的下标为A+SZ(A.L)+1，其中SZ(A.L)为A的左子树大小。

        若A的区间为[l,r],则A的左子树的区间为[l,(l+r)>>1]，所以SZ(A.L)=(mid-l+1)\*2-1=(mid-l)*2+1=((r-l-1)/2)\*2+1，则A的右子树的下标为A+((r-l-1)/2\*2)

        http://www.cppblog.com/MatoNo1/archive/2015/05/05/195857.html

        

   5. 多维推广

      矩阵树，空间树

      如两种不同参数找到最适变量（一个人的身高和体重，找到一定范围内且年龄最小的人）

   6. 非递归形式

   7. 子树收缩

      子树继承的逆过程。继承是为了得到父节点信息，而收缩则是在回溯时如果两棵子树拥有相同数据时将数据传递给父节点，子树的数据清空，下次访问时可以减少访问的结点数

      

   8. zkw线段树

      思想一致，都是节点维护区间信息，但zkw线段树是循环式的，同时支持很多操作

      ![img](https://images2018.cnblogs.com/blog/1452724/201808/1452724-20180821160156936-1884947255.jpg)

      ![img](https://images2018.cnblogs.com/blog/1452724/201808/1452724-20180821223038494-1334459442.jpg)

      https://blog.csdn.net/keshuqi/article/details/52205884

      https://www.cnblogs.com/Judge/p/9514862.html

   9. 

7. 参考资料

   https://blog.csdn.net/zearot/article/details/48299459

   https://www.cnblogs.com/xenny/p/9801703.html
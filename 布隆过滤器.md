[toc]

#### 简介

由一个很长的二进制向量和一系列随机映射函数组成，用于判断一个元素是否在集合中。

其优点是空间效率和查询时间效率高，缺点是存在假阳性（实际上不在集合中的元素可能被布隆过滤器认为在集合中）但不存在假阴性，并且不支持删除操作。

不同于哈希表的是，hash函数存在冲突从而导致容量有限。

布隆过滤器的额外优势：

- 不要求知道key，有一定的隐私保护属性
- 便于硬件并行实现，效率可提高

### 基本思想

借助k个hash函数和一个n比特的数组，将某个key加入集合时，根据hash函数对key的映射结果，将数组的相应位置置为1，判断某个key是否在集合时，根据hash函数对该key的映射结果，如果在数组上的相应位置均为1，则认为在集合中。

### 应用场景

存储系统的设计中，存在空查询缺陷，当查询一个不存在的key时，需要访问慢查询设备，导致效率低下，可以在查询前端和后端之间设置一个布隆过滤器，降低后端压力。

### 基本原理

假定数组的比特数为m，哈希函数个数为k，插入一个元素对某一个哈希函数的映射下对某个位置上没有被置为1的概率为$$1-\frac{1}{m}$$，那么k个哈希函数这一个位置仍未被置1的概率是$$(1-\frac{1}{m})^k$$，当插入n个元素后，这一位置上仍旧未被置1的概率是$$(1-\frac{1}{m})^{nk}$$，现检查某一个元素是否在该集合中出现假阳性（不在集合中的元素被判定为在集合中）的概率是$$(1-(1-\frac{1}{m})^{kn})^{k}  $$。

根据上述原理，可以调整m和k的大小来调整出现假阳性的概率。

### 扩展

- Counting Filter，支持删除操作的方法，在Counting Filter中每个位扩展成n个位即数组变成一个二维数组，此时Bloom Filter可以认为是一个只有1位计数器的Counting Filter，但这种方式不具备伸缩性，也存在算数溢出问题。
- Data synchronization
- Scalable Bloom Filter
- Stable Bloom Filter
- Compact approximately
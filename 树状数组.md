1. 什么是树状数组？

   用数组模拟树形结构，在一些没有必要建树的场景中，构造思想有点类似于前缀树（Trie Tree)

2. 树状数组的应用

   可以解决大部分基于区间上的更新和求和问题

3. 树状数组 vs 线段树

   树状数组可以解决的问题都可以用线段树来解决。

   但树状数组的系数小很多，修改和查询的复杂度都是对数级别，比线段树少，比传统数组快，易于实现

4. 基本概念

   二叉树的结构

   

   ![img](https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121208845-81274925.png)树状数组的结构

   ![img](https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png)

   原始数组（A[i]）为黑色框，红色框代表树状数组(C[i])

   恒等式

   （1） $$C[i]=A[i-2^k+1]+A[i-2^k+2]+...+A[i]$$，其中k为i的二进制中从最低位到高位连续0的长度即$$lowbit(i)=2^k=i\&(-i)$$

   （2）$$Sum[i] =C[i] + C[i-2^{k1}]+...C[(i-2^{k2})-2^{k1})]+...$$

5. 基本原理

   **本质上二进制上面的应用，理解了lowbit就能理解树状数组。**

   - 建立阶段

      $$C[i]=A[i-2^k+1]+A[i-2^k+2]+...+A[i]$$

     => 与$$A[i]$$相关有$$C[i]、C[i+2^k]、C[i+2^k+2^k]、...$$

     ```c++
     int n;
     int maxn;
     int a[maxn],c[maxn];
     
     int lowbit(int x){
     	return x&(-x)
     }
     
     // a[i]=a[i]+k
     void update(int i,int k){
       for (i<=n) {
         c[i]+=k;
         i+=lowbit(i);
       }
     }
     // 求A[1-i]的和
     int getSum(int i){
       int res=0;
       for (i>0) {
         res+=c[i];
         i-=lowbit(i);
       }
       return res;
     }
     ```

   - 单点更新、单点查询 -- 传统数组可解

   - 单点更新、区间查询 -- getSum()做修改

   - 区间更新、单点查询 -- 差分建树

     规定$$A[0]=0,A[i]=\Sigma_{j=1}^{i}{D[j]},D[j]=A[j]-A[j-1]$$

     可以发现：**当进行区间$$[x,y]$$修改时，区间内的D[i]是不变的，只有D[x]和D[y+1]会发生变化**，等价于将更新一个区间的值转换成只更新两个点。

     基于是上述事实，在差分数组山上立树状数组。

     【题】https://www.luogu.org/problem/show?pid=3368

   - 区间更新、区间查询 -- 差分建树

     $$\Sigma_{i=1}^{n}{A[i]}=\Sigma_{i=1}^{n}\Sigma_{j=1}^{i}{D[j]}$$

     则$$A[1]+...+A[n]=(D[1])+(D[1]+D[2])+...+(D[1]+...+D[n])=n*(D[1]+...+D[n])-(0*D[1]+1*D[2]+...+(n-1)*D[n])\\=n*\Sigma_{i=1}^{n}{D[i]}-\Sigma_{i=1}^{n}{D[i]*(i-1)}$$

     所以维护两个树状数组，$$Sum1[i]=D[i],Sum2[i]=D[i]*(i-1)$$

     【题】https://vjudge.net/problem/POJ-3468

6. 关于lowbit的解释

   这里利用的负数的存储特性，负数是以补码存储的，对于整数运算 x&(-x)有
       ● 当x为0时，即 0 & 0，结果为0；
       ●当x为奇数时，最后一个比特位为1，取反加1没有进位，故x和-x除最后一位外前面的位正好相反，按位与结果为0。结果为1。
       ●当x为偶数，且为2的m次方时，x的二进制表示中只有一位是1（从右往左的第m+1位），其右边有m位0，故x取反加1后，从右到左第有m个0，第m+1位及其左边全是1。这样，x& (-x) 得到的就是x。 
       ●当x为偶数，却不为2的m次方的形式时，可以写作x= y * (2^k)。其中，y的最低位为1。实际上就是把x用一个奇数左移k位来表示。这时，x的二进制表示最右边有k个0，从右往左第k+1位为1。当对x取反时，最右边的k位0变成1，第k+1位变为0；再加1，最右边的k位就又变成了0，第k+1位因为进位的关系变成了1。左边的位因为没有进位，正好和x原来对应的位上的值相反。二者按位与，得到：第k+1位上为1，左边右边都为0。结果为2^k。
       总结一下：x&(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。

7. 参考资料

   https://www.cnblogs.com/xenny/p/9739600.html

   

   
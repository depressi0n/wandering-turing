[TOC]



## 网络

#### （1）什么是HTTP？

HTTP，超文本传输协议的缩写，互联网广泛使用的一种网络协议。默认使用80端口，由客户端发起请求，建立一个与服务器指定端口的TCP连接（可以引出TCP和UDP有什么不同，使用TCP的原因是打开一个网页会传送很多数据，TCP协议提供了传输控制，按序交付，错误纠正）

#### （2）HTTP 请求方式

GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、OPTIONS

其中GET和POST的区别：
GET一般用于向服务器获取数据，没有请求体，仅支持ASCII码，安全，幂等，明文，可缓存的
POST一般用于向服务器发送数据，有请求体，支持标准字符集，不安全的，非幂等，不可缓存


#### （3）HTTP/1.0 vs HTTP/1.1

HTTP/1.1 默认采用持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少建立和关闭连接到消耗和延迟。

HTTP/1.1 允许客户端流水线操作，不用等待上一次请求到结果返回就可以发送下一次请求，以减少整个过程的时间消耗

HTTP/1.1 中Header中可以有Connection，当其值为close时，正在使用的TCP连接在请求处理完毕后就会被断掉，当其值均为Keep-alive时保持连接

HTTP/1.1 增加了请求头和响应头来改进和扩充HTTP/1.0的功能，如Host（支持一台Web服务器在同一个IP地址和端口上使用不同的主机名来创建多个虚拟Web站点），提供缓存控制策略（如Entity tag，If-Unmodified-Since，If-Match，If-None-Match等），支持断点续传（Range，状态码对应206），增加错误状态响应码，引入Cookie保存状态信息

#### （4） HTTP/2.0

多路复用：允许通过单一的HTTP/2连接发起多重的请求-响应消息，主要解决HTTP/1.1的串形文件传输【借助二进制分帧+流】和连接数限制问题【借助流】

二进制分帧：在HTTP/2和传输层（TCP or UDP）之间增加二进制分帧，改进传输性能

首部压缩：DEFLATE算法（SPDY算法，强制使用HTTPS），HPACK算法，每个请求都要发送消息头，通过维护一个词典差量更新

服务端推送：在客户端请求发送之前发送数据，可以缓存数据

#### （5）HTTP vs HTTPS

HTTPS = HTTP + SSL/TLS（Secure Sockets Layer，涉及非对称加密，对称加密，HASH算法，序列号机制防止重放）

HTTPS 要求在传输数据之前客户端和服务器之间进行证书认证、密钥协商，

TLS过程：

* 浏览器将一套加密规则（对称加密算法、非对称加密算法、MAC算法、Nonce）发送给服务器
* 服务器从中选择一组加密算法和MAC算法，并将自己的身份信息以证书的形式（网址、加密公钥、证书颁发机构、过期时间等）发送给浏览器
* 浏览器验证证书合法性，生成一串随机数作为**通信密钥**，并使用约定的HASH算法计算握手信息，使用通信密钥对握手信息加密，通信密钥用服务器的公钥加密，都发送给服务器
* 服务器使用私钥解密获取通信密钥，再使用通信密钥解密握手信息并验证HASH值，验证完成后使用通信密钥加密一段握手信息发送浏览器
* （协商完通信密钥之后重新进行一次加密规则的协商 === *有内鬼，终止交易*）
* 浏览器使用通信密钥解密握手消息并计算HASH，并验证。
* 之后所有的通信都使用通信密钥进行通信（如果报文太大，TLS会做分割形成多个记录，序列号也会在MAC算法中作为输入）

主要区别：证书、明文/密文传输、端口443/80

HTTPS通信过程（分为ECDHE握手、RSA握手，不同之处在于RSA握手是直接由客户端生成）：

- 客户端与服务器首先建立TCP连接（DNS获取IP，然后TCP三次握手）
- 客户端向服务端443端口发起请求（Client Hello），将一套算法（支持的协议版本、支持的加密算法、Hash算法、Nonce1）发送给服务器
- 服务器选择算法（确认版本、确认加密算法），并将自己的信息（网址、公钥、证书颁发机构、证书过期时间）【通过证书形式】和Nonce2发送给客户端
- 客户端验证证书合法性，验证通过后生成随机值（Nonce3，与Nonce1和Nonce2一起生成session key和MAC key），使用服务器的公钥加密将“握手信息（改用会话密钥通信和所有握手数据的摘要）” 都发送给服务器 
- 服务器解密，验证Hash值，并生成响应的密钥，发送“握手信息（改用会话密钥通信和所有握手数据的摘要）”给客户端
- 服务器和客户端之后的通信用协商的密钥进行请求/响应

[参考链接](http://www.360doc.com/content/20/1119/19/37113458_946750481.shtml)：建议查看，比这里更详细，有图更容易理解

#### （6）TCP和UDP有什么不同

TCP：面向连接的、可靠（三次握手+四次挥手、校验和、序列号、超时重传、流量控制、拥塞控制、确认应答机制）交付、流量控制、拥塞控制、全双工、面向字节流、仅支持一对一

UDP：无连接的、尽最大可能交付、面向报文、支持点对点+多播+广播

#### （7）TCP 3次握手和4次挥手

三次握手：（两次握手不行是因为只能客户端的起始序列号被确认，而服务端的序列号不会被确认，不一定可靠）

* 客户端发送数据包（SYN=1，seq=x），进入syn_sent状态，等待服务端确认
* 服务端回复数据包（SYN=1，ACK=x+1，seq=y），进入syn_rcvd状态（此时请求连接被放在半连接队列中，SYN攻击--发送大量半连接请求，占用半连接队列，耗费CPU和内存，可以通过缩短SYN Timeout事件或者限制给定IP的半连接数目来防范）
* 客户端确认数据包（ACK=y+1，seq=x+1），双方进入established状态

四次挥手：（双方确认对方的连接关闭，等待2MSL的原因是保证上一次连接的报文已经从网络中消失并且接收重发的第四次挥手）

* 客户端发送数据报（FIN=1，seq=z），进入fin_wait_1状态
* 服务端回复数据包（ACK=z+1），进入close_wait状态（半关闭状态，客户端已经没有要发送的数据但可以接受服务端的数据）
* 服务端发送数据包（FIN=1，seq=w），进入last_ack状态
* 客户端回复数据包（ACK=w+1）之前进入time_wait状态，回复后双方进入closed状态

#### （8）session 和 Cookie的区别

session： 保存在服务端，session id存放在cookie中，一般用于用户验证，

cookie： 由服务端产生，在客户端保存，一般用于标识客户端

#### （9）浏览器从输入网址到显示整个页面的经历

* 对域名进行格式化检查
* 根据域名查看本地缓存（检查是否过期，更新资源刷新缓存或读取缓存）
* 根据域名通过DNS解析得到IP地址，会经过ARP（广播询问，单播回复）获取网关的MAC地址，将数据包发送给网关，由网关交付给本地DNS服务器，查询IP地址，DNS查询会经历浏览器缓存-操作系统缓存-路由器缓存-ISP DNS 缓存-根域名服务器
* 与服务器指定端口建立TCP连接，经历三次握手（也需要经过上面的走网关交付路由器流程），建立连接后，发送HTTP请求，转成TCP报文交付给路由器，经过IP路由后交付给服务器，中间会经过MAC地址变化
* 服务器处理请求并回复
* 浏览器接收到响应资源后，对响应资源进行处理并解析响应内容
* 由浏览器内核对页面进行渲染（DOM树、CSS规则树、渲染树、JS执行）

#### （10） 网络协议模型

OSI七层协议：物理层（二进制比特流传输）、数据链路层（封装成帧，透明传输，差错检测CRC）、网络层（路由选择算法，IP首部，ARP、ICMP、IGMP，路由器，RIP/OSPF、BGP）、传输层（拥塞控制、流量控制、差错控制，提供进程间的逻辑通信）、会话层（建立--身份+权限、保持--维护、断开--释放）、表示层（数据格式编译）、应用层（HTTP协议、FTP协议等）

TCP/IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层

#### （11）TCP粘包

TCP是面向字节流的，多个小尺寸数据可能被封装在一个TCP报文中，而接收方一次性读完
处理方法：固定发送消息长度，加入消息分隔符

#### （12）滑动窗口（流量控制） vs  拥塞控制 vs 差错控制

滑动窗口：接收方告知发送方 -- 接收窗口的大小，从而控制发送方的速度

拥塞控制：发送方维护拥塞窗口大小，慢开始（每接一次报文，指数增加）、拥塞避免（经过一个RTT，拥塞窗口加1）、快恢复（拥塞时将门限值设置为拥塞时发送窗口的一半，并将拥塞窗口设置为门限值）、快重传（三个ACK，不需要等待计时器超时）

差错控制：校验和、ACK、超时重传

#### （13）DNS协议

基于UDP的应用层协议，功能是根据域名解析处出P地址。

过程：

* 客户端发出查询请求，先在本地缓存中查找，未找到则发送给dns服务器
* 本地dns服务器在自己区域内查找，未找到则本地缓存中查找，仍未找到则将请求发送给根域名服务器
* 根域名服务器解析根域部分，回复包含下一级的dns服务器给本地dns服务器
* 本地dns服务器根据返回的信息接着访问下一级的dns服务器（递归），获取IP信息
* 本地dns服务器将查询结果返回给客户机
* 客户机收到添加缓存，完成解析过程

#### （14） ping命令使用哪些协议

ping命令使用的是ICMP协议（Internet控制报文协议，传输时封装在IP报文中）

#### （15）负载均衡

（1）什么是负载均衡

将工作负载分布到多个服务器来提高性能和可靠性的机制，涉及到的负载均衡算法有：轮询、最小连接、IP散列

（2）有哪些负载均衡？

七层（应用层）负载均衡：Nginx【用户态，相对比较重】

四层（传输层）负载均衡：LVS，修改报文头目标地址，如果需要也可修改源地址，接收到客户端的SYN请求时，通过负载均衡算法选择一个最佳服务器，并对报文中目标地址IP进行修改--最佳服务器IP，转发给该 服务器，TCP建立连接（客户端和服务器直接建立连接，LVS只起到一个类似路由器转发的功能）【LVS是Linux内核模块，工作在内核态】

DNS负载均衡：在解析域名时随机调度，类似于HTTP重定向转换策略


------



## Linux

#### （1）awk

|      内部变量      |             含义             |
| :----------------: | :--------------------------: |
|         $0         |            当前行            |
| \$1,\$2,\$3...,\$n |      当前行的第n个字段       |
|         NF         |       当前行的字段数目       |
|       FNR/NR       |             行号             |
|         FS         |       分隔符，默认空格       |
|        OFS         |     输出分隔符，默认空格     |
|         RS         |     行分隔符，默认换行符     |
|        ORS         |   输出行分隔符，默认换行符   |
|      FILENAME      | 当前处理的文件名，默认换行符 |

支持正则表达式
 `/root/{ statements}` 匹配所有包含“root”的行，对应sed中`/root/p`
`$5~/root/{statements}` 匹配第5个字短包含“root”的行

支持地址定位 
`NR==1,NR==5 {statements}` 打印第2行到第5行，对应sed中`1,5p`

#### （2）sed

```shell
sed [-hnV][-e<script>][-f<script文件>][文本文件]
```

参数说明：

- -e\<script\>或--expression=\<script\> 以选项中指定的script来处理输入的文本文件。
- -f\<script文件\>或--file=\<script文件\> 以选项中指定的script文件来处理输入的文本文件。
- -h或--help 显示帮助。
- -n或--quiet或--silent 仅显示script处理后的结果。
- -V或--version 显示版本信息。

动作说明

- a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)

- c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！

- d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；

- i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；

- p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～

- s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！

  

#### （3）grep

```shell
grep [-abcEFGhHilLnqrsvVwxy][-A<显示行数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]
```



#### (4) wc

```shell
wc [-clw][--help][--version][文件...]
```

**参数**：

- -c或--bytes或--chars 只显示Bytes数。
- -l或--lines 显示行数。
- -w或--words 只显示字数。
- --help 在线帮助。
- --version 显示版本信息。

默认情况下计算行数、字数、字节数



#### （5）find

```shell
find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;
```



#### （6）xargs

给命令传递参数的过滤器，可以将管道或标准输入数据转换为命令行参数，也可以从文件的输出中读取数据；可以将单行或多行文件输入转换为其他格式

-n 多行输出
-d 自定义分隔符
-I 指定一个替换字符串，每一个参数都会执行一次命令











------------







## OS

#### （1）什么是OS

管理计算机软硬件资源的程序，提供给用户和硬件之间的接口，向上对用户程序提供接口，向下管理资源，负责处理器调度（公平、非阻塞、优先级）、内存管理（抽象足够大的虚拟内存内存空间，共享内存）、I/O（设备）管理（屏蔽不同设备之间的差异、提供并发访问）、文件系统（易用性）、健壮性管理、安全性管理，保证计算机资源公平竞争和使用，防止对计算机资源的非法侵占和使用，并保证自身正常运转。

#### （2）用户态和内核态

为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。

内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。

用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。

用户程序运行在用户态,操作系统内核运行在内核态。

切换：系统调用（软中断）、异常（内中断，由错误引起如文件损坏、缺页故障等）、外部中断（硬中断）

#### （3）虚拟内存

对主存的抽象，提供三个能力：

* 将主存看成一个存储在磁盘上的地址空间的高速缓存，主存中只保存活动区域，根据需要替换数据，高效利用主存
* 为每一个进程提供一致的地址空间，简化内存管理
* 保护进程的地址空间不被其他进程破坏

页面置换算法：

FIFO、LRU（最常用）、LFU

虚拟地址向物理地址的转换过程：

* 虚拟地址=虚拟页号+页偏移，首先查快表（存放在内存管理单元--MMU中）中页面映射关系，失败（可并行）则页表（虚拟页号->页框号）中找到页框号
* 真实地址=物理页地址+页偏移 

每个进程的控制信息中存储当前进程“页目录”的物理地址，通过这个地址找到“页目录”，其中存储物理内存页起始地址的“页表”，32位下这样的两级页表足够存储寻址空间为4GB大小的内存空间了。利用页表中存储的记录中存储的内存页起始地址（因为起始地址必然是对应一个4KB的页，所以低12位是全0，可以用这些位记录页相关信息如是否可读、可写、可执行、是否已经映射等信息 ）】

#### （4）进程通信 vs 线程通信

进程通信

​	匿名管道（pipe）：调用pipe函数创建，只支持半双工通信（单向交替传输），只能在父子进程或兄弟进程中使用，随进程消亡而消亡

​	高级管道通信（popen）：将另一个程序当作一个新的进程在当前程序启动

​	命名管道（named pipe）：去除了管道（pipe）只能在父子进程中使用的限制，常用于客户-服务应用程序中，命名管道用作客户端汇聚点

​	消息队列（message queue）：独立于读写进程而存在，不需要进程自己提供同步方法，读进程可以根据消息类型选择性接收消息，但通信不及时、大小受限、用户态和内核态的拷贝

​	共享内存（shared memory）：拿出一块虚拟空间映射到相同的物理内存中，速度最快，通常需要使用信号量互斥访问。

​	信号量（semaphore）：计数器，用于多个进程提供对共享数据对象的访问，实现进程间的互斥和同步（锁机制）

​	信号（signal）：唯一的异步通信机制，用于通知接受进程某事件已经发生

​	Socket：跨网络，不同主机进程通信，域（网络介质）+类型（流 or 数据报）+协议

线程通信

​	共享进程的资源，全局变量

#### （5）进程、线程、协程

进程：资源分配的基本单位，独立运行的基本单位，包括PCB、程序段和数据段，切换代价大（因为TLB会失效等 ）

线程：调度的基本单位，独立的寄存器组、指令计数器、处理器状态，与同一进程下线程共享地址空间

协程：线程创建的执行体，只能分配用户栈，也称为用户态线程，思想关键在于控制流的主动让出和恢复，每个协程拥有自己的协程栈，可以保存自己的执行现场。

区别：

（1）从属关系，独立性，通信方式，相互之间

（2）进程同步方法：互斥锁、读写锁、条件变量、记录锁、信号量、屏障
		  线程同步方法：互斥锁、读写锁、条件变量、信号量、自旋锁、屏障

虚拟地址空间被划分为内核空间和用户空间。

进程控制信息在内核空间中，包括页目录、ID、父进程ID、状态、打开文件句柄表，线程是进程中的执行体，要有指定的执行入口。 

线程控制信息在内核空间中，包括执行入口、线程栈（操作系统会分配两段栈--用户栈和内核栈，线程切换到内核态运行时会切换到内核栈，为了不允许用户代码对齐进行修改保护安全）、线程ID等。

当需要执行某个线程时，IP指向该线程的执行入口，栈基和栈指针寄存器会记录用户栈的位置【这意味着程序执行时CPU面向的是某个线程，所以说线程是操作系统调度和执行的基本单位】

一个进程中至少要有一个线程 -- 主线程，一般是有父进程或操作系统创建的，其他线程一般是由主线程创建的，线程发生函数调用时则在线程栈中分配函数调用栈，线程调用系统服务（虚拟内存分配、文件操作、网络读写等）时通过**系统调用**（最初是软中断--通过指令模拟中断，系统调用表+中断向量表，后来改为通过特殊指令触发 ，从专用寄存器拿派发入口地址，省去查询中断向量表的过程）来完成。

线程切换：保存当前线程执行现场如指令指针、栈指针等寄存器的值，修改为切换线程的寄存器值，内存中调度相关的数据结构

进程切换：CPU保存的页目录地址要修改为切换进程的页目录地址，会导致地址空间等进程资源发生变化，会导致TLB缓存失效

协程与IO多路复用：
IO多路复用会涉及到socket，而socket操作都有操作系统来提供，进程控制信息中会保存socket文件句柄，每个TCP socket创建时OS都会为其分配一个读缓冲区和写缓冲区（在内核空间中，需要完成拷贝到用户空间的操作）。
当出现没有数据可以读或者写缓冲区满时，怎么处理：
（1）阻塞式IO -- 让出CPU，进入等待队列，处理一个socket就要一个线程，在高并发场景下会加剧调度开销
（2）非阻塞式IO -- 不让出CPU，频繁检查socker是否就绪，容易造成空耗CPU，加剧延迟
（3）IO多路复用 -- 由操作系统提供支持，将需要等待的socket加入监听集合，通过一次系统调用，同时监听多个socket
		【1】select：每次都要传入所有监听集合，需要频繁从用户态到内核态拷贝数据，就绪时也需要遍历
		【2】poll： 监听数目等于可打开的文件符个数
		【3】epoll：
（4）信号驱动
（5）异步I/O

总体来看 -- 就绪时需要恢复现场，陷入等待时需要保存现场   -> 协程很适合

#### （6）死锁

条件：互斥、不可抢占、占有并请求、循环等待

解决：资源一次性分配（破坏请求）、可抢占资源（破坏不可抢占）、资源有序分配（破坏循环等待）

避免：银行家算法

#### （7）缓存穿透、缓存击穿、缓存雪崩

缓存穿透：缓存和数据库中都没有的数据，可能属于攻击，可以通过校验防范

缓存击穿：缓存中没有但数据库中有的数据，由于并发用户多且访问同一数据，同时缓存中没有读到，导致数据库压力瞬间增大，可以通过设置热点数据永不过期和互斥锁或者布隆过滤器来防范

缓存雪崩：缓存中数据大批量到了过期时间，而查询数量巨大，引起数据库压力过大甚至宕机，可以通过设置随机过期时间+热点数据均匀分布+永不过期来防范

#### （8）进程调度

可以调度：

* 当前进程运行结束
* 当前进程阻塞
* 系统调用后返回用户进程
* 抢占式+高优先级
* 时间片耗尽

不可调度：

* 中断程序处理
* 内核程序临界区
* 屏蔽中断的原子操作过程中

调度策略：

FCFS、SJF、优先级调度、时间片轮转、高响应比、多级队列、多级反馈队列

#### （9）同步的本质

实现临界区操作的互斥性，单核状态下，借助硬件指令（Compare And Swap、Fecth And Add、Test And Set等）实现锁机制，但在多核状态下，仅依靠硬件指令是不够的，需要借助总线锁（一旦使用了总线锁，则从并行变成了串行），而当前的缓存机制使得为了保证多核间高速缓存的一致性，引入了MESI协议（高速缓存一致性协议）

---------



## 数据库

#### （1）三大范式

第一范式：表中所有字段值都是不可分解的原子值

第二范式：所有非主属性都完全依赖于主码

第三范式：所有非主属性对任何候选关键字都不存在传递依赖（即跟主键有直接关系）

#### (2) HAVING 和 WHERE 的差别

WHERE 在数据分组前进行过滤，排除的行不包括在分组中

HAVING 在数据分组后进行过滤

#### (3) ORDER BY 和 GROUP BY的区别

ORDER BY 排序产生的输出，任何列都可以使用

GROUP BY 用于分组行，但输出可能不是分组的顺序，只可能使用选择列或表达式列而且必须使用每个选择列表达式

#### (4) Mysql 中子句的顺序

```
SELECT xxx 
FROM table_x
WHERE
GROUP BY
HAVING
ORDER BY
LIMIT
OFFSET
```

